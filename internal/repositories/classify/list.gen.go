// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package classify

import (
	"context"
	"runtime/debug"

	page "github.com/gorm-gen/paginate/gen"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/repositories"

	"example/internal/models"
)

type _list struct {
	core          *Classify
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// List 获取数据列表
func (c *Classify) List() *_list {
	return &_list{
		core:          c,
		unscoped:      c.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (l *_list) Tx(tx *query.Query) *_list {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_list) QueryTx(tx *query.QueryTx) *_list {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_list) Select(field ...field.Expr) *_list {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_list) ForUpdate() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_list) ForUpdateSkipLocked() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_list) ForUpdateNoWait() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_list) ForShare() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_list) ForShareSkipLocked() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_list) ForShareNoWait() *_list {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_list) Unscoped() *_list {
	l.unscoped = true
	return l
}

func (l *_list) Scopes(funcs ...func(gen.Dao) gen.Dao) *_list {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_list) Relation(opts ...RelationOption) *_list {
	l.relationOpts = append(l.relationOpts, opts...)
	return l
}

func (l *_list) Order(opts ...OrderOption) *_list {
	l.orderOpts = append(l.orderOpts, opts...)
	return l
}

func (l *_list) Where(opts ...ConditionOption) *_list {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

func (l *_list) WriteDB() *_list {
	l.writeDB = true
	return l
}

// Page 列表分页
func (l *_list) Page(page, pageSize uint) *_list {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

// Do 执行获取数据列表
func (l *_list) Do(ctx context.Context) ([]*models.Classify, error) {
	lq := l.core.q.Classify
	if l.tx != nil {
		lq = l.tx.Classify
	}
	if l.qTx != nil {
		lq = l.qTx.Classify
	}
	lr := lq.WithContext(ctx)
	if l.core.newTableName != nil && *l.core.newTableName != "" {
		lr = lq.Table(*l.core.newTableName).WithContext(ctx)
	}
	if _len := len(l.selects); _len > 0 {
		if l.core.newTableName == nil {
			lr = lr.Select(l.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range l.selects {
				fs = append(fs, field.NewField(*l.core.newTableName, v.ColumnName().String()))
			}
			lr = lr.Select(fs...)
		}
	}
	if l.writeDB {
		lr = lr.WriteDB()
	}
	if l.unscoped {
		lr = lr.Unscoped()
	}
	if len(l.scopes) > 0 {
		lr = lr.Scopes(l.scopes...)
	}
	if (l.tx != nil || l.qTx != nil) && l.lock != nil {
		lr = lr.Clauses(l.lock)
	}
	if _len := len(l.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range l.conditionOpts {
			conditions = append(conditions, opt(l.core))
		}
		if len(conditions) > 0 {
			lr = lr.Where(conditions...)
		}
	}
	if _len := len(l.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range l.orderOpts {
			orders = append(orders, opt(l.core))
		}
		if len(orders) > 0 {
			lr = lr.Order(orders...)
		}
	}
	if l.page > 0 && l.pageSize > 0 {
		lr = lr.Scopes(page.Paginate(l.page, l.pageSize))
	}
	if _len := len(l.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range l.relationOpts {
			relations = append(relations, opt(l.core))
		}
		if len(relations) > 0 {
			lr = lr.Preload(relations...)
		}
	}
	list, err := lr.Find()
	if err != nil {
		if repositories.IsRealErr(err) {
			l.core.logger.Error("【Classify.List】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return list, nil
}
