// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package order

import (
	"context"
	"fmt"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"

	"example/internal/query"

	"example/internal/models"
)

type _shardingCreate struct {
	core      *Order
	tx        *query.Query
	qTx       *query.QueryTx
	unscoped  bool
	values    []*models.Order
	batchSize int
	scopes    []func(gen.Dao) gen.Dao
}

// ShardingCreate 分表添加数据
func (o *Order) ShardingCreate() *_shardingCreate {
	return &_shardingCreate{
		core:     o,
		unscoped: o.unscoped,
		values:   make([]*models.Order, 0),
		scopes:   make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (c *_shardingCreate) Tx(tx *query.Query) *_shardingCreate {
	c.tx = tx
	if tx != nil {
		c.qTx = nil
	}
	return c
}

// QueryTx 设置为手动事务
func (c *_shardingCreate) QueryTx(tx *query.QueryTx) *_shardingCreate {
	c.qTx = tx
	if tx != nil {
		c.tx = nil
	}
	return c
}

func (c *_shardingCreate) Unscoped(unscoped ...bool) *_shardingCreate {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	c.unscoped = _unscoped
	return c
}

func (c *_shardingCreate) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingCreate {
	c.scopes = append(c.scopes, funcs...)
	return c
}

func (c *_shardingCreate) Values(values ...*models.Order) *_shardingCreate {
	c.values = append(c.values, values...)
	return c
}

// BatchSize 当批量插入时指定创建的数量
func (c *_shardingCreate) BatchSize(batchSize uint) *_shardingCreate {
	c.batchSize = int(batchSize)
	return c
}

// Do 执行添加数据
func (c *_shardingCreate) Do(ctx context.Context) (err error) {
	length := len(c.values)
	if length == 0 {
		return nil
	}
	bs := uint(c.batchSize)
	if length == 1 {
		cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(c.values...).Scopes(c.scopes...)
		if c.unscoped {
			cr = cr.Unscoped()
		}
		return cr.Do(ctx)
	}
	m := make(map[string][]*models.Order, length)
	for _, value := range c.values {
		m[value.Sharding] = append(m[value.Sharding], value)
	}
	if len(m) == 1 {
		cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(c.values...).Scopes(c.scopes...)
		if c.unscoped {
			cr = cr.Unscoped()
		}
		return cr.Do(ctx)
	}
	if c.tx != nil || c.qTx != nil {
		for _, values := range m {
			cr := c.core.Create().Tx(c.tx).QueryTx(c.qTx).BatchSize(bs).Values(values...).Scopes(c.scopes...)
			if c.unscoped {
				cr = cr.Unscoped()
			}
			if err = cr.Do(ctx); err != nil {
				return
			}
		}
		return
	}
	return c.core.q.Transaction(func(tx *query.Query) (err error) {
		defer func() {
			if r := recover(); r != nil {
				c.core.logger.Error("【Order.ShardingCreate】执行异常", zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
				err = fmt.Errorf("recovered from panic: %v", r)
				return
			}
		}()
		for _, values := range m {
			cr := c.core.Create().Tx(tx).BatchSize(bs).Values(values...).Scopes(c.scopes...)
			if c.unscoped {
				cr = cr.Unscoped()
			}
			if err = cr.Do(ctx); err != nil {
				return
			}
		}
		return
	})
}
