// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package order

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/models"
)

type _shardingFirst struct {
	core          *Order
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	conditionOpts []ConditionOption
	sharding      []string
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingFirst 获取分表中随机第一条记录（主键升序）
func (o *Order) ShardingFirst(sharding []string) *_shardingFirst {
	return &_shardingFirst{
		core:          o,
		unscoped:      true,
		selects:       make([]field.Expr, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (f *_shardingFirst) Worker(worker chan struct{}) *_shardingFirst {
	if worker == nil {
		return f
	}
	f.worker = worker
	return f
}

// Tx 设置为事务
func (f *_shardingFirst) Tx(tx *query.Query) *_shardingFirst {
	f.tx = tx
	if tx != nil {
		f.qTx = nil
	}
	return f
}

// QueryTx 设置为手动事务
func (f *_shardingFirst) QueryTx(tx *query.QueryTx) *_shardingFirst {
	f.qTx = tx
	if tx != nil {
		f.tx = nil
	}
	return f
}

func (f *_shardingFirst) Select(field ...field.Expr) *_shardingFirst {
	f.selects = append(f.selects, field...)
	return f
}

func (f *_shardingFirst) ForUpdate() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return f
}

func (f *_shardingFirst) ForUpdateSkipLocked() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_shardingFirst) ForUpdateNoWait() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_shardingFirst) ForShare() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return f
}

func (f *_shardingFirst) ForShareSkipLocked() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *_shardingFirst) ForShareNoWait() *_shardingFirst {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *_shardingFirst) Unscoped(unscoped ...bool) *_shardingFirst {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	f.unscoped = _unscoped
	return f
}

func (f *_shardingFirst) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingFirst {
	f.scopes = append(f.scopes, funcs...)
	return f
}

func (f *_shardingFirst) Where(opts ...ConditionOption) *_shardingFirst {
	f.conditionOpts = append(f.conditionOpts, opts...)
	return f
}

func (f *_shardingFirst) WriteDB() *_shardingFirst {
	f.writeDB = true
	return f
}

// Do 执行获取分表中随机第一条记录（主键升序）
func (f *_shardingFirst) Do(ctx context.Context) (*models.Order, error) {
	if len(f.sharding) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	_condLen := len(f.conditionOpts)
	wg := sync.WaitGroup{}
	endChan := make(chan struct{})
	errChan := make(chan error)
	resultChan := make(chan *models.Order)
	for _, sharding := range f.sharding {
		f.worker <- struct{}{}
		wg.Add(1)
		go func(sharding string) {
			defer func() {
				if r := recover(); r != nil {
					f.core.logger.Error(fmt.Sprintf("【Order.ShardingFirst.%s】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan <- fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				<-f.worker
			}()
			defer wg.Done()
			_conditionOpts := make([]ConditionOption, _condLen, _condLen+1)
			copy(_conditionOpts, f.conditionOpts)
			_conditionOpts = append(_conditionOpts, ConditionSharding(sharding))
			fr := f.core.First()
			fr.lock = f.lock
			fr.writeDB = f.writeDB
			res, err := fr.Tx(f.tx).
				QueryTx(f.qTx).
				Select(f.selects...).
				Unscoped(f.unscoped).
				Scopes(f.scopes...).
				Where(_conditionOpts...).
				Do(ctx)
			if err != nil {
				if !errors.Is(err, gorm.ErrRecordNotFound) {
					errChan <- err
				}
				return
			}
			resultChan <- res
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan <- struct{}{}
	}()
	select {
	case res := <-resultChan:
		return res, nil
	case <-endChan:
		return nil, gorm.ErrRecordNotFound
	case err := <-errChan:
		return nil, err
	}
}
