// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/plugin/repository. DO NOT EDIT.

package order

import (
	"context"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"example/internal/query"

    "example/internal/repositories"

    "example/internal/models"
)

type first struct {
	core          *Order
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	conditionOpts []ConditionOption
}

// First 获取第一条记录（主键升序）
func (o *Order) First() *first {
	return &first{
		core:          o,
		unscoped:      o.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (f *first) Tx(tx *query.Query) *first {
	f.tx = tx
	if tx != nil {
		f.qTx = nil
	}
	return f
}

// QueryTx 设置为手动事务
func (f *first) QueryTx(tx *query.QueryTx) *first {
	f.qTx = tx
	if tx != nil {
		f.tx = nil
	}
	return f
}

func (f *first) Select(field ...field.Expr) *first {
	f.selects = append(f.selects, field...)
	return f
}

func (f *first) ForUpdate() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return f
}

func (f *first) ForUpdateSkipLocked() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *first) ForUpdateNoWait() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *first) ForShare() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return f
}

func (f *first) ForShareSkipLocked() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return f
}

func (f *first) ForShareNoWait() *first {
	f.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return f
}

func (f *first) Unscoped() *first {
	f.unscoped = true
	return f
}

func (f *first) Relation(opts ...RelationOption) *first {
	f.relationOpts = append(f.relationOpts, opts...)
	return f
}

func (f *first) Where(opts ...ConditionOption) *first {
	f.conditionOpts = append(f.conditionOpts, opts...)
	return f
}

// Do 执行获取第一条记录（主键升序）
func (f *first) Do(ctx context.Context) (*models.Order, error) {
	fq := f.core.q.Order
	if f.tx != nil {
		fq = f.tx.Order
	}
	if f.qTx != nil {
		fq = f.qTx.Order
	}
	fr := fq.WithContext(ctx)
	if f.core.newTableName != nil && *f.core.newTableName != "" {
		fr = fq.Table(*f.core.newTableName).WithContext(ctx)
	}
	if len(f.selects) > 0 {
		if f.core.newTableName == nil {
			fr = fr.Select(f.selects...)
		} else {
			fs := make([]field.Expr, 0, len(f.selects))
			for _, v := range f.selects {
				fs = append(fs, field.NewField(*f.core.newTableName, v.ColumnName().String()))
			}
			fr = fr.Select(fs...)
		}
	}
	if f.unscoped {
		fr = fr.Unscoped()
	}
	if (f.tx != nil || f.qTx != nil) && f.lock != nil {
		fr = fr.Clauses(f.lock)
	}
	if len(f.conditionOpts) > 0 {
		conditions := make([]gen.Condition, 0, len(f.conditionOpts))
		for _, opt := range f.conditionOpts {
			conditions = append(conditions, opt(f.core))
		}
		if len(conditions) > 0 {
			fr = fr.Where(conditions...)
		}
	}
	if len(f.relationOpts) > 0 {
		relations := make([]field.RelationField, 0, len(f.relationOpts))
		for _, opt := range f.relationOpts {
			relations = append(relations, opt(f.core))
		}
		if len(relations) > 0 {
			fr = fr.Preload(relations...)
		}
	}
	res, err := fr.First()
	if err != nil {
		if repositories.IsRealErr(err) {
			f.core.logger.Error("【Order.First】失败", zap.Error(err))
		}
		return nil, err
	}
	return res, nil
}
