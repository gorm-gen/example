// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package order

import (
	"context"
	"errors"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/repositories"

	"example/internal/models"
)

type _shardingTake struct {
	core          *Order
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	sharding      []string
	worker        chan struct{}
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingTake 获取分表中随机一条记录
func (o *Order) ShardingTake(sharding []string) *_shardingTake {
	return &_shardingTake{
		core:          o,
		unscoped:      o.unscoped,
		selects:       make([]field.Expr, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (t *_shardingTake) Worker(worker chan struct{}) *_shardingTake {
	if worker == nil {
		return t
	}
	t.worker = worker
	return t
}

// Tx 设置为事务
func (t *_shardingTake) Tx(tx *query.Query) *_shardingTake {
	t.tx = tx
	if tx != nil {
		t.qTx = nil
	}
	return t
}

// QueryTx 设置为手动事务
func (t *_shardingTake) QueryTx(tx *query.QueryTx) *_shardingTake {
	t.qTx = tx
	if tx != nil {
		t.tx = nil
	}
	return t
}

func (t *_shardingTake) Select(field ...field.Expr) *_shardingTake {
	t.selects = append(t.selects, field...)
	return t
}

func (t *_shardingTake) ForUpdate() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return t
}

func (t *_shardingTake) ForUpdateSkipLocked() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_shardingTake) ForUpdateNoWait() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_shardingTake) ForShare() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return t
}

func (t *_shardingTake) ForShareSkipLocked() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_shardingTake) ForShareNoWait() *_shardingTake {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_shardingTake) Unscoped() *_shardingTake {
	t.unscoped = true
	return t
}

func (t *_shardingTake) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingTake {
	t.scopes = append(t.scopes, funcs...)
	return t
}

func (t *_shardingTake) Order(opts ...OrderOption) *_shardingTake {
	t.orderOpts = append(t.orderOpts, opts...)
	return t
}

func (t *_shardingTake) Where(opts ...ConditionOption) *_shardingTake {
	t.conditionOpts = append(t.conditionOpts, opts...)
	return t
}

func (t *_shardingTake) WriteDB() *_shardingTake {
	t.writeDB = true
	return t
}

// Do 执行获取分表中随机一条记录
func (t *_shardingTake) Do(ctx context.Context) (*models.Order, error) {
	if len(t.sharding) == 0 {
		return nil, gorm.ErrRecordNotFound
	}
	tq := t.core.q.Order
	if t.tx != nil {
		tq = t.tx.Order
	}
	if t.qTx != nil {
		tq = t.qTx.Order
	}
	var conditions []gen.Condition
	if _len := len(t.conditionOpts); _len > 0 {
		conditions = make([]gen.Condition, 0, _len)
		for _, opt := range t.conditionOpts {
			conditions = append(conditions, opt(t.core))
		}
	}
	var fieldExpr []field.Expr
	if _len := len(t.selects); _len > 0 {
		fieldExpr = make([]field.Expr, 0, _len)
		if t.core.newTableName == nil {
			fieldExpr = append(fieldExpr, t.selects...)
		} else {
			for _, v := range t.selects {
				fieldExpr = append(fieldExpr, field.NewField(*t.core.newTableName, v.ColumnName().String()))
			}
		}
	}
	var orders []field.Expr
	if _len := len(t.orderOpts); _len > 0 {
		orders = make([]field.Expr, 0, _len)
		for _, opt := range t.orderOpts {
			orders = append(orders, opt(t.core))
		}
	}
	wg := sync.WaitGroup{}
	endChan := make(chan struct{})
	errChan := make(chan error)
	resultChan := make(chan *models.Order)
	for _, sharding := range t.sharding {
		t.worker <- struct{}{}
		wg.Add(1)
		go func(sharding string) {
			defer func() {
				if r := recover(); r != nil {
					t.core.logger.Error(fmt.Sprintf("【Order.ShardingTake.%s】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan <- fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				<-t.worker
			}()
			defer wg.Done()
			_conditions := make([]gen.Condition, len(conditions))
			copy(_conditions, conditions)
			_conditions = append(_conditions, ConditionSharding(sharding)(t.core))
			tr := tq.WithContext(ctx)
			if len(fieldExpr) > 0 {
				tr = tr.Select(fieldExpr...)
			}
			if t.writeDB {
				tr = tr.WriteDB()
			}
			if t.unscoped {
				tr = tr.Unscoped()
			}
			if len(t.scopes) > 0 {
				tr = tr.Scopes(t.scopes...)
			}
			if (t.tx != nil || t.qTx != nil) && t.lock != nil {
				tr = tr.Clauses(t.lock)
			}
			tr = tr.Where(_conditions...)
			if len(orders) > 0 {
				tr = tr.Order(orders...)
			}
			res, err := tr.Take()
			if err != nil {
				if repositories.IsRealErr(err) {
					t.core.logger.Error(fmt.Sprintf("【Order.ShardingTake.%s】失败", sharding), zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				if !errors.Is(err, gorm.ErrRecordNotFound) {
					errChan <- err
				}
				return
			}
			resultChan <- res
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan <- struct{}{}
	}()
	select {
	case res := <-resultChan:
		return res, nil
	case <-endChan:
		return nil, gorm.ErrRecordNotFound
	case err := <-errChan:
		return nil, err
	}
}
