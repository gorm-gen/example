// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package orderItem

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	"github.com/opentracing/opentracing-go"
	"go.uber.org/zap"
	"gorm.io/gen"

	"example/internal/query"

	"example/internal/repositories"
)

type _shardingUpdate struct {
	core          *OrderItem
	tx            *query.Query
	qTx           *query.QueryTx
	unscoped      bool
	updateOpts    []UpdateOption
	conditionOpts []ConditionOption
	sharding      []int
	worker        chan struct{}
	scopes        []func(gen.Dao) gen.Dao
	trace         bool
}

// ShardingUpdate 更新分表数据
func (o *OrderItem) ShardingUpdate(sharding []int) *_shardingUpdate {
	return &_shardingUpdate{
		core:          o,
		unscoped:      o.unscoped,
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
		updateOpts:    make([]UpdateOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
	}
}

func (u *_shardingUpdate) Worker(worker chan struct{}) *_shardingUpdate {
	if worker == nil {
		return u
	}
	u.worker = worker
	return u
}

// Tx 设置为事务
func (u *_shardingUpdate) Tx(tx *query.Query) *_shardingUpdate {
	u.tx = tx
	if tx != nil {
		u.qTx = nil
	}
	return u
}

// QueryTx 设置为手动事务
func (u *_shardingUpdate) QueryTx(tx *query.QueryTx) *_shardingUpdate {
	u.qTx = tx
	if tx != nil {
		u.tx = nil
	}
	return u
}

func (u *_shardingUpdate) Unscoped(unscoped ...bool) *_shardingUpdate {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	u.unscoped = _unscoped
	return u
}

func (u *_shardingUpdate) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingUpdate {
	u.scopes = append(u.scopes, funcs...)
	return u
}

// Update update fields
//
// Deprecated: The future will be removed, this function simply calls [Set].
//
//go:fix inline
func (u *_shardingUpdate) Update(opts ...UpdateOption) *_shardingUpdate {
	return u.Set(opts...)
}

func (u *_shardingUpdate) Set(opts ...UpdateOption) *_shardingUpdate {
	u.updateOpts = append(u.updateOpts, opts...)
	return u
}

func (u *_shardingUpdate) Where(opts ...ConditionOption) *_shardingUpdate {
	u.conditionOpts = append(u.conditionOpts, opts...)
	return u
}

func (u *_shardingUpdate) Trace() *_shardingUpdate {
	u.trace = true
	return u
}

// Do 执行更新分表数据
func (u *_shardingUpdate) Do(ctx context.Context) (int64, map[int]int64, error) {
	if u.trace {
		if parent := opentracing.SpanFromContext(ctx); parent != nil {
			if tracer := opentracing.GlobalTracer(); tracer != nil {
				span := tracer.StartSpan("SQL:OrderItem.ShardingUpdate", opentracing.ChildOf(parent.Context()))
				defer span.Finish()
			}
		}
	}
	_lenSharding := len(u.sharding)
	if len(u.updateOpts) == 0 || _lenSharding == 0 {
		return 0, nil, nil
	}
	qTx := u.qTx
	var innerTx *query.QueryTx
	var cancel context.CancelFunc
	if u.tx == nil && u.qTx == nil {
		innerTx = u.core.q.Begin()
		qTx = innerTx
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
	}
	_condLen := len(u.conditionOpts)
	sm := sync.Map{}
	wg := sync.WaitGroup{}
	errChan := make(chan error, _lenSharding)
	endChan := make(chan struct{}, 1)
	for _, sharding := range u.sharding {
		u.worker <- struct{}{}
		wg.Add(1)
		go func(sharding int) {
			defer func() {
				if r := recover(); r != nil {
					u.core.logger.Error(fmt.Sprintf("【OrderItem.ShardingUpdate.%d】执行异常", sharding), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan <- fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				<-u.worker
			}()
			defer wg.Done()
			_conditionOpts := make([]ConditionOption, _condLen, _condLen+1)
			copy(_conditionOpts, u.conditionOpts)
			_conditionOpts = append(_conditionOpts, ConditionSharding(sharding))
			rows, err := u.core.Update().
				Tx(u.tx).
				QueryTx(qTx).
				Unscoped(u.unscoped).
				Scopes(u.scopes...).
				Where(_conditionOpts...).
				Update(u.updateOpts...).
				Do(ctx)
			if err != nil {
				errChan <- err
				return
			}
			sm.Store(sharding, rows)
			return
		}(sharding)
	}
	go func() {
		wg.Wait()
		endChan <- struct{}{}
	}()
	select {
	case <-endChan:
		if innerTx != nil {
			if err := innerTx.Commit(); err != nil {
				if repositories.IsRealErr(err) {
					u.core.logger.Error("【OrderItem.ShardingUpdate.Commit】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
				}
				return 0, nil, err
			}
		}
		rowsAffected := int64(0)
		m := make(map[int]int64, _lenSharding)
		sm.Range(func(key, value interface{}) bool {
			v := value.(int64)
			m[key.(int)] = v
			rowsAffected += v
			return true
		})
		return rowsAffected, m, nil
	case err := <-errChan:
		if innerTx != nil {
			cancel()
			_ = innerTx.Rollback()
		}
		return 0, nil, err
	case <-ctx.Done():
		return 0, nil, ctx.Err()
	}
}
