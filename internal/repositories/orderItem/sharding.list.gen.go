// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package orderItem

import (
	"context"
	"fmt"
	"runtime"
	"runtime/debug"
	"sync"

	page "github.com/gorm-gen/paginate/gen"
	"github.com/gorm-gen/sharding/query/list"
	"github.com/shopspring/decimal"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/models"
)

type _shardingList struct {
	core          *OrderItem
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	offset        int64
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	sharding      []int
	worker        chan struct{}
	asc           bool
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// ShardingList 获取分表数据列表
func (o *OrderItem) ShardingList(sharding []int) *_shardingList {
	return &_shardingList{
		core:          o,
		unscoped:      true,
		selects:       make([]field.Expr, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		sharding:      sharding,
		worker:        make(chan struct{}, runtime.NumCPU()),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

func (l *_shardingList) Worker(worker chan struct{}) *_shardingList {
	if worker == nil {
		return l
	}
	l.worker = worker
	return l
}

// Offset 单表单次查询最多一次查询多少条数据
func (l *_shardingList) Offset(offset int64) *_shardingList {
	if offset > 0 {
		l.offset = offset
	}
	return l
}

// Desc sharding列表倒序
func (l *_shardingList) Desc() *_shardingList {
	l.asc = false
	return l
}

// Asc sharding列表正序
func (l *_shardingList) Asc() *_shardingList {
	l.asc = true
	return l
}

// Tx 设置为事务
func (l *_shardingList) Tx(tx *query.Query) *_shardingList {
	l.tx = tx
	if tx != nil {
		l.qTx = nil
	}
	return l
}

// QueryTx 设置为手动事务
func (l *_shardingList) QueryTx(tx *query.QueryTx) *_shardingList {
	l.qTx = tx
	if tx != nil {
		l.tx = nil
	}
	return l
}

func (l *_shardingList) Select(field ...field.Expr) *_shardingList {
	l.selects = append(l.selects, field...)
	return l
}

func (l *_shardingList) ForUpdate() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return l
}

func (l *_shardingList) ForUpdateSkipLocked() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingList) ForUpdateNoWait() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingList) ForShare() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return l
}

func (l *_shardingList) ForShareSkipLocked() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return l
}

func (l *_shardingList) ForShareNoWait() *_shardingList {
	l.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return l
}

func (l *_shardingList) Unscoped(unscoped ...bool) *_shardingList {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	l.unscoped = _unscoped
	return l
}

func (l *_shardingList) Scopes(funcs ...func(gen.Dao) gen.Dao) *_shardingList {
	l.scopes = append(l.scopes, funcs...)
	return l
}

func (l *_shardingList) Order(opts ...OrderOption) *_shardingList {
	l.orderOpts = append(l.orderOpts, opts...)
	return l
}

func (l *_shardingList) Where(opts ...ConditionOption) *_shardingList {
	l.conditionOpts = append(l.conditionOpts, opts...)
	return l
}

// Page 列表分页
func (l *_shardingList) Page(page, pageSize uint) *_shardingList {
	l.page = int(page)
	l.pageSize = int(pageSize)
	return l
}

func (l *_shardingList) WriteDB() *_shardingList {
	l.writeDB = true
	return l
}

// Do 执行获取分表数据列表
func (l *_shardingList) Do(ctx context.Context) ([]*models.OrderItem, int64, error) {
	empty := make([]*models.OrderItem, 0)
	_lenSharding := len(l.sharding)
	if _lenSharding == 0 {
		return empty, 0, nil
	}
	ctx, cancel := context.WithCancel(ctx)
	defer cancel()
	// 获取分表数据总记录
	shardingCount := l.core.ShardingCount(l.sharding).
		Worker(l.worker).
		Tx(l.tx).
		QueryTx(l.qTx).
		Unscoped(l.unscoped).
		Where(l.conditionOpts...)
	if l.writeDB {
		shardingCount = shardingCount.WriteDB()
	}
	count, m, err := shardingCount.Do(ctx)
	if err != nil {
		return nil, 0, err
	}
	if count == 0 {
		return empty, 0, nil
	}
	// 获取分表分页数据
	svs := make([]*list.St, 0, _lenSharding)
	for k, v := range m {
		svs = append(svs, &list.St{
			ShardingValue: fmt.Sprintf("%d", k),
			Total:         uint64(v),
		})
	}
	listOpts := []list.Option{
		list.WithPage(uint64(l.page)),
		list.WithPageSize(uint64(l.pageSize)),
	}
	if l.offset > 0 {
		listOpts = append(listOpts, list.WithOffset(uint64(l.offset)))
	}
	if l.asc {
		listOpts = append(listOpts, list.WithAsc())
	} else {
		listOpts = append(listOpts, list.WithDesc())
	}
	slList := list.New(svs, listOpts...).Analysis()
	slList.ToSliceIndex()
	// 获取分表数据
	_condLen := len(l.conditionOpts)
	wg := sync.WaitGroup{}
	_count_ := int64(0)
	_list_ := make([][]*models.OrderItem, len(slList))
	endChan := make(chan struct{})
	errChan := make(chan error)
	for k, v := range slList {
		l.worker <- struct{}{}
		wg.Add(1)
		_count_ += v.Num
		go func(k int, v list.Sl) {
			defer func() {
				if r := recover(); r != nil {
					l.core.logger.Error(fmt.Sprintf("【OrderItem.ShardingList.%s】执行异常-1", v.ShardingValue), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
					errChan <- fmt.Errorf("recovered from panic: %v", r)
				}
			}()
			defer func() {
				<-l.worker
			}()
			defer wg.Done()
			_wg := &sync.WaitGroup{}
			_endChan := make(chan struct{})
			_errChan := make(chan error)
			__list := make([][]*models.OrderItem, len(v.List))
			for kk, vv := range v.List {
				l.worker <- struct{}{}
				_wg.Add(1)
				go func(kk int, vv list.Sld) {
					defer func() {
						if r := recover(); r != nil {
							l.core.logger.Error(fmt.Sprintf("【OrderItem.ShardingList.%s】执行异常-2", v.ShardingValue), zap.Any("recover", r), zap.ByteString("debug.Stack", debug.Stack()))
							_errChan <- fmt.Errorf("recovered from panic: %v", r)
						}
					}()
					defer func() {
						<-l.worker
					}()
					defer _wg.Done()
					_conditionOpts := make([]ConditionOption, _condLen, _condLen+1)
					copy(_conditionOpts, l.conditionOpts)
					_shardingValue, _ := decimal.NewFromString(v.ShardingValue)
					shardingValue := int(_shardingValue.BigInt().Int64())
					_conditionOpts = append(_conditionOpts, ConditionSharding(shardingValue))
					lr := l.core.List()
					lr.writeDB = l.writeDB
					lr.lock = l.lock
					var res []*models.OrderItem
					res, err = lr.Tx(l.tx).
						QueryTx(l.qTx).
						Select(l.selects...).
						Unscoped(l.unscoped).
						Scopes(l.scopes...).
						Where(_conditionOpts...).
						Order(l.orderOpts...).
						Scopes(page.Paginate(vv.Page, vv.PageSize)).
						Do(ctx)
					if err != nil {
						_errChan <- err
						return
					}
					__list[kk] = res[vv.Start:vv.End]
				}(kk, vv)
			}
			go func() {
				_wg.Wait()
				_endChan <- struct{}{}
			}()
			select {
			case <-_endChan:
				___list := make([]*models.OrderItem, 0, v.Num)
				for _, vvv := range __list {
					___list = append(___list, vvv...)
				}
				_list_[k] = ___list
				return
			case err = <-_errChan:
				errChan <- err
				return
			}
		}(k, v)
	}
	go func() {
		wg.Wait()
		endChan <- struct{}{}
	}()
	select {
	case <-endChan:
		__list := make([]*models.OrderItem, 0, _count_)
		for _, v := range _list_ {
			__list = append(__list, v...)
		}
		return __list, count, nil
	case err = <-errChan:
		return nil, 0, err
	}
}
