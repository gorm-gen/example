// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package user

import (
	"context"
	"runtime/debug"

	page "github.com/gorm-gen/paginate/gen"
	"github.com/opentracing/opentracing-go"
	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/repositories"
)

type _scan struct {
	core          *User
	tx            *query.Query
	qTx           *query.QueryTx
	page          int
	pageSize      int
	lock          clause.Expression
	dest          interface{}
	scopes        []func(gen.Dao) gen.Dao
	selects       []field.Expr
	unscoped      bool
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
	trace         bool
}

// Scan 从数据库中查询多个列并扫描结果到切片
func (u *User) Scan(dest interface{}) *_scan {
	return &_scan{
		core:          u,
		unscoped:      u.unscoped,
		dest:          dest,
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
		selects:       make([]field.Expr, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
	}
}

// Tx 设置为事务
func (s *_scan) Tx(tx *query.Query) *_scan {
	s.tx = tx
	if tx != nil {
		s.qTx = nil
	}
	return s
}

// QueryTx 设置为手动事务
func (s *_scan) QueryTx(tx *query.QueryTx) *_scan {
	s.qTx = tx
	if tx != nil {
		s.tx = nil
	}
	return s
}

func (s *_scan) Select(field ...field.Expr) *_scan {
	s.selects = append(s.selects, field...)
	return s
}

func (s *_scan) ForUpdate() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return s
}

func (s *_scan) ForUpdateSkipLocked() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return s
}

func (s *_scan) ForUpdateNoWait() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return s
}

func (s *_scan) ForShare() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return s
}

func (s *_scan) ForShareSkipLocked() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return s
}

func (s *_scan) ForShareNoWait() *_scan {
	s.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return s
}

func (s *_scan) Unscoped(unscoped ...bool) *_scan {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	s.unscoped = _unscoped
	return s
}

func (s *_scan) Order(opts ...OrderOption) *_scan {
	s.orderOpts = append(s.orderOpts, opts...)
	return s
}

// Page 列表分页
func (s *_scan) Page(page, pageSize uint) *_scan {
	s.page = int(page)
	s.pageSize = int(pageSize)
	return s
}

func (s *_scan) Where(opts ...ConditionOption) *_scan {
	s.conditionOpts = append(s.conditionOpts, opts...)
	return s
}

func (s *_scan) WriteDB() *_scan {
	s.writeDB = true
	return s
}

func (s *_scan) Scopes(funcs ...func(gen.Dao) gen.Dao) *_scan {
	s.scopes = append(s.scopes, funcs...)
	return s
}

func (s *_scan) Trace() *_scan {
	s.trace = true
	return s
}

// Do 执行从数据库中查询多个列并扫描结果到切片
func (s *_scan) Do(ctx context.Context) error {
	if s.trace {
		if parent := opentracing.SpanFromContext(ctx); parent != nil {
			if tracer := opentracing.GlobalTracer(); tracer != nil {
				span := tracer.StartSpan("SQL:User.Scan", opentracing.ChildOf(parent.Context()))
				defer span.Finish()
			}
		}
	}
	sq := s.core.q.User
	if s.tx != nil {
		sq = s.tx.User
	}
	if s.qTx != nil {
		sq = s.qTx.User
	}
	sr := sq.WithContext(ctx)
	if s.core.newTableName != nil && *s.core.newTableName != "" {
		sr = sq.Table(*s.core.newTableName).WithContext(ctx)
	}
	if _len := len(s.selects); _len > 0 {
		sr = sr.Select(s.selects...)
	}
	if s.writeDB {
		sr = sr.WriteDB()
	}
	if s.unscoped {
		sr = sr.Unscoped()
	}
	if len(s.scopes) > 0 {
		sr = sr.Scopes(s.scopes...)
	}
	if (s.tx != nil || s.qTx != nil) && s.lock != nil {
		sr = sr.Clauses(s.lock)
	}
	if _len := len(s.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range s.conditionOpts {
			conditions = append(conditions, opt(s.core))
		}
		if len(conditions) > 0 {
			sr = sr.Where(conditions...)
		}
	}
	if _len := len(s.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range s.orderOpts {
			orders = append(orders, opt(s.core))
		}
		if len(orders) > 0 {
			sr = sr.Order(orders...)
		}
	}
	if s.page > 0 && s.pageSize > 0 {
		sr = sr.Scopes(page.Paginate(s.page, s.pageSize))
	}
	if err := sr.Scan(s.dest); err != nil {
		if repositories.IsRealErr(err) {
			s.core.logger.Error("【User.Scan】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return err
	}
	return nil
}
