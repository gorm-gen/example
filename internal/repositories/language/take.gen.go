// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.
// Code generated by github.com/gorm-gen/repository. DO NOT EDIT.

package language

import (
	"context"
	"runtime/debug"

	"go.uber.org/zap"
	"gorm.io/gen"
	"gorm.io/gen/field"
	"gorm.io/gorm/clause"

	"example/internal/query"

	"example/internal/repositories"

	"example/internal/models"
)

type _take struct {
	core          *Language
	tx            *query.Query
	qTx           *query.QueryTx
	lock          clause.Expression
	unscoped      bool
	selects       []field.Expr
	relationOpts  []RelationOption
	orderOpts     []OrderOption
	conditionOpts []ConditionOption
	writeDB       bool
	scopes        []func(gen.Dao) gen.Dao
}

// Take 获取一条记录
func (l *Language) Take() *_take {
	return &_take{
		core:          l,
		unscoped:      l.unscoped,
		selects:       make([]field.Expr, 0),
		relationOpts:  make([]RelationOption, 0),
		orderOpts:     make([]OrderOption, 0),
		conditionOpts: make([]ConditionOption, 0),
		scopes:        make([]func(gen.Dao) gen.Dao, 0),
	}
}

// Tx 设置为事务
func (t *_take) Tx(tx *query.Query) *_take {
	t.tx = tx
	if tx != nil {
		t.qTx = nil
	}
	return t
}

// QueryTx 设置为手动事务
func (t *_take) QueryTx(tx *query.QueryTx) *_take {
	t.qTx = tx
	if tx != nil {
		t.tx = nil
	}
	return t
}

func (t *_take) Select(field ...field.Expr) *_take {
	t.selects = append(t.selects, field...)
	return t
}

func (t *_take) ForUpdate() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate}
	return t
}

func (t *_take) ForUpdateSkipLocked() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_take) ForUpdateNoWait() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthUpdate, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_take) ForShare() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare}
	return t
}

func (t *_take) ForShareSkipLocked() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsSkipLocked}
	return t
}

func (t *_take) ForShareNoWait() *_take {
	t.lock = clause.Locking{Strength: clause.LockingStrengthShare, Options: clause.LockingOptionsNoWait}
	return t
}

func (t *_take) Unscoped(unscoped ...bool) *_take {
	_unscoped := true
	if len(unscoped) > 0 {
		_unscoped = unscoped[0]
	}
	t.unscoped = _unscoped
	return t
}

func (t *_take) Scopes(funcs ...func(gen.Dao) gen.Dao) *_take {
	t.scopes = append(t.scopes, funcs...)
	return t
}

func (t *_take) Relation(opts ...RelationOption) *_take {
	t.relationOpts = append(t.relationOpts, opts...)
	return t
}

func (t *_take) Order(opts ...OrderOption) *_take {
	t.orderOpts = append(t.orderOpts, opts...)
	return t
}

func (t *_take) Where(opts ...ConditionOption) *_take {
	t.conditionOpts = append(t.conditionOpts, opts...)
	return t
}

func (t *_take) WriteDB() *_take {
	t.writeDB = true
	return t
}

// Do 执行获取一条记录
func (t *_take) Do(ctx context.Context) (*models.Language, error) {
	tq := t.core.q.Language
	if t.tx != nil {
		tq = t.tx.Language
	}
	if t.qTx != nil {
		tq = t.qTx.Language
	}
	tr := tq.WithContext(ctx)
	if t.core.newTableName != nil && *t.core.newTableName != "" {
		tr = tq.Table(*t.core.newTableName).WithContext(ctx)
	}
	if _len := len(t.selects); _len > 0 {
		if t.core.newTableName == nil {
			tr = tr.Select(t.selects...)
		} else {
			fs := make([]field.Expr, 0, _len)
			for _, v := range t.selects {
				fs = append(fs, field.NewField(*t.core.newTableName, v.ColumnName().String()))
			}
			tr = tr.Select(fs...)
		}
	}
	if t.writeDB {
		tr = tr.WriteDB()
	}
	if t.unscoped {
		tr = tr.Unscoped()
	}
	if len(t.scopes) > 0 {
		tr = tr.Scopes(t.scopes...)
	}
	if (t.tx != nil || t.qTx != nil) && t.lock != nil {
		tr = tr.Clauses(t.lock)
	}
	if _len := len(t.conditionOpts); _len > 0 {
		conditions := make([]gen.Condition, 0, _len)
		for _, opt := range t.conditionOpts {
			conditions = append(conditions, opt(t.core))
		}
		if len(conditions) > 0 {
			tr = tr.Where(conditions...)
		}
	}
	if _len := len(t.orderOpts); _len > 0 {
		orders := make([]field.Expr, 0, _len)
		for _, opt := range t.orderOpts {
			orders = append(orders, opt(t.core))
		}
		if len(orders) > 0 {
			tr = tr.Order(orders...)
		}
	}
	if _len := len(t.relationOpts); _len > 0 {
		relations := make([]field.RelationField, 0, _len)
		for _, opt := range t.relationOpts {
			relations = append(relations, opt(t.core))
		}
		if len(relations) > 0 {
			tr = tr.Preload(relations...)
		}
	}
	res, err := tr.Take()
	if err != nil {
		if repositories.IsRealErr(err) {
			t.core.logger.Error("【Language.Take】失败", zap.Error(err), zap.ByteString("debug.Stack", debug.Stack()))
		}
		return nil, err
	}
	return res, nil
}
